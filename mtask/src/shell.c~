#include "kernel.h"
#include "apps.h"

#define BUFSIZE 200
#define NARGS 20
#define PROMPT "MT> "

static struct cmdentry
{
	char *name;
	int (*func)(int argc, char **argv);
}
cmdtab[] =
{
	{	"setkb",		setkb_main },
	{	"shell",		shell_main },
	{	"sfilo",		simple_phil_main },
	{	"filo",			phil_main },
	{	"xfilo",		extra_phil_main },
	{	"afilo",		atomic_phil_main },
	{	"camino",		camino_main },
	{	"camino_ns",	camino_ns_main },
	{	"prodcons",		prodcons_main },
	{	"divz",			divz_main },
	{ }
};

int
shell_main(int argc, char **argv)
{
	char buf[BUFSIZE];
	char *args[NARGS+1];
	unsigned nargs;
	struct cmdentry *cp;
	unsigned fg, bg;

	mt_cons_getattr(&fg, &bg);
	while ( true )
	{
		mt_cons_setattr(LIGHTGRAY, BLACK);
		//****aca habria que cambiar el nombre de la terminal*/
		cprintk(LIGHTCYAN, BLACK, PROMPT);

		/* leer linea de comando, fraccionarla en tokens y armar argv */
		mt_getline(buf, sizeof buf);
		nargs = separate(buf, args, NARGS);
		if ( !nargs )
			continue;
		args[nargs] = NULL;

		/* comandos internos */
		if ( strcmp(args[0], "help") == 0 )
		{
			printk("Comandos internos:\n");
			printk("\thelp\n");
			printk("\tclear\n");
			printk("\texit\n");
			printk("\treboot\n");
			printk("Aplicaciones:\n");\
			for ( cp = cmdtab ; cp->name ; cp++ )
				printk("\t%s\n", cp->name);
			continue;
		}

		if ( strcmp(args[0], "exit") == 0 )
		{
			mt_cons_setattr(fg, bg);
			return nargs > 1 ? atoi(args[1]) : 0;
		}

		if ( strcmp(args[0], "clear") == 0 )
		{
			mt_cons_clear();
			continue;
		}

		if ( strcmp(args[0], "reboot") == 0 )
		{
			*(short *) 0x472 = 0x1234;
			while ( true )
				outb(0x64, 0xFE);
		}

		/* aplicaciones */
		bool found = false;
		for ( cp = cmdtab ; cp->name ; cp++ )
			if ( strcmp(args[0], cp->name) == 0 )
			{
				found = true;
				int n = cp->func(nargs, args);
				if ( n != 0 )
					cprintk(LIGHTRED, BLACK, "Status: %d\n", n);
				break;
			}

		if ( !found )
			cprintk(LIGHTRED, BLACK, "Comando %s desconocido\n", args[0]);
	}
}

void
mt_shell_autoComplete(char* buf){
	
	struct cmdentry *cp;
	char *args[NARGS+1];
	unsigned nargs;

	unsigned size = strlen(buf);
	int foundC = 0;

	//printk("size:%d\n",size);
	//printk("buf:%s\n",buf);
	//args[0]=NULL;
	nargs = separate(buf, args, NARGS);
	//printk("args:%s\n",args[0]);
	//printk("nargs:%d\n",nargs);
	if ( nargs != 0 ){
		args[nargs] = NULL;

		//printk("%d",strncmp(args[0], "help", size-1));
		/* comandos internos */
		if ( strncmp(args[0], "help", size-1) == 0 )
		{
			//printk("entra\n");
			mt_mtty_cleanLine(size);
			//printk("bufA:%s\n",args[0]);
			strcpy(buf, "help\n");
			//printk("bufD:%s\n",args[0]);
			mt_mtty_getCommand(buf);
			return;
		}
		/*if ( strncmp(args[0], "exit", size-1) == 0 )
		{
			mt_mtty_cleanLine(size);
			strcpy(args[0], "exit\n");
			mt_mtty_getCommand(args[0]);
			return;
		}
		if ( strncmp(args[0], "clear", size-1) == 0 )
		{
			mt_mtty_cleanLine(size);
			strcpy(args[0], "clear\n");
			mt_mtty_getCommand(args[0]);
			return;
		}

		if ( strncmp(args[0], "reboot", size-1) == 0 )
		{
			mt_mtty_cleanLine(size);
			strcpy(args[0], "reboot\n");
			mt_mtty_getCommand(args[0]);
			return;
		}*/

	}
	
}
